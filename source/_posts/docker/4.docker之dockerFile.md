---
title: docker之dockerFile
myPath: docker-file
categories:
- docker
tags: docker
date:
cover: ../images/docker/21/5/7/docker.png
---
### 概念
我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，这个脚本就是Dockerfile；
Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建；

### dockerFile指令
基本指令如图：
[![](https://z3.ax1x.com/2021/05/07/g8knCd.jpg)](https://imgtu.com/i/g8knCd)
从上图我们可以看到dockerFile的一些相关指令，
完整指令如图：
[![](https://z3.ax1x.com/2021/05/07/g8Aoyq.jpg)](https://imgtu.com/i/g8Aoyq)
### 自定义一个centos镜像
[![](https://z3.ax1x.com/2021/05/07/g8VCgs.png)](https://imgtu.com/i/g8VCgs)
我们现在写一个dockerFile自定义一个centos镜像让它有这些命令；

构建一个dockerFile我们一定要有一个dockerFile文件，文件的命名可以随意，但是不建议随意命名，官方的命名就是DockerFile;
我们在本机的home目录下新建一个文件`dokerFile`
```shell
cd /home
mkdir dockerFile
cd dockerFile
vim myDokerFile-centos
```

[![](https://z3.ax1x.com/2021/05/10/gNXWVg.png)](https://imgtu.com/i/gNXWVg)
可以看到我们是基于centos来构建的，注明了作者，定义了一个MYPATH的环境变量并指定为工作目录，在运行构建的时候安装vim命令和网络工具，对外暴露的是80端口，容器启动的时候输出自定义的环境变量，构建完成后输出一个bilid-end标记；最后跳转到默认的控制台；

有了这个dockerFile后我们基于它构建一个我们自己的镜像
```shell
docker build -f myDokerFile-centos -t mycentos:1.0 . # -f指哪个文件 不指定就会去找默认的名为DockeFile的文件 -t起个镜像的名字 注意最后的点别掉了
```
[![](https://z3.ax1x.com/2021/05/08/g8n9oV.png)](https://imgtu.com/i/g8n9oV)

我们通过命令看下镜像的构建历史，可以看到镜像确实是按照我们的命令一层一层构建的；而且每一条命令执行完毕，就提交生成一个新的镜像层；
[![](https://z3.ax1x.com/2021/05/08/g8nUTP.png)](https://imgtu.com/i/g8nUTP)、

### CMD & ENTRYPOINT
疑问？我们构建镜像的时候，用了三个CMD命令，发现只有最后一个CMD命令生效了，其实关于dockerfile 的CMD和ENTRYPOINT 命令有一个的区别，其中一个最主要的区别的时，CMD，ENTRYPOINT 命令编写多个时会只有最后一个生效，其中CMD命令如果在启动的时候加了命令会被替换，而ENTRYPOINT命令如果在启动的时候加了命令是在原命令中追加；具体实践很简单，自己尝试下即可；

CMD和ENTRYPOINT的应用场景，比如我们指定环境的运行内存时，如果我们用了CMD命令，那么用户在启动镜像的时候就可以更改；如果我们使用了ENTRYPOINT命令，那么用户只能在启动容器的时候追加命令，不能更改；

如果在Dockerfile中同时写了ENTRYPOINT和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT 的参数；

如果在Dockerfile中同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效

### dockerFile卷挂载
之前我们使用-v命令指定了tomcat的目录挂载，接下来我们看看另外一种挂载方式：dockerFile卷挂载

同样我们还是在home目录下新建一个测试目录，测试下dockerFile的卷挂载
[![gN41Vx.png](https://z3.ax1x.com/2021/05/10/gN41Vx.png)](https://imgtu.com/i/gN41Vx)
vim 进去我们编写一个简单的dockerFile脚步
```shell
FROM centos
VOLUME ["/datavolume01","/datavolume02]
CMD echo "------build-end-----"
CMD /bin/bash
```
注📢：命令后面都要用空格
我们执行看下
[![](https://z3.ax1x.com/2021/05/10/gNb4c8.png)](https://imgtu.com/i/gNb4c8)
执行完毕后，我们启动刚刚创建的镜像，看下下面的挂载，果然已经挂载了我们需要的目录
[![](https://z3.ax1x.com/2021/05/10/gNqOVH.png)](https://imgtu.com/i/gNqOVH)
接下来我们进入datavolume01下，新建一个aaa.text文件，后面看下这个文件被同步到哪里去了；
[![](https://z3.ax1x.com/2021/05/10/gNXtKK.png)](https://imgtu.com/i/gNXtKK)
我们新开一个窗口，看下运行中的docker,因为我们运行镜像时没有起容器的别名，所以docker给了个默认的名称，我们看最新运行的那个镜像即可
[![](https://z3.ax1x.com/2021/05/10/gNLmR0.png)](https://imgtu.com/i/gNLmR0)
```shell
"Mounts": [
    {
        "Type": "volume",
        "Name": "b50422404045013251322ac0e02f64aee621898a89c1d78c0d78e77b53724eaa",
        "Source": "/var/lib/docker/volumes/b50422404045013251322ac0e02f64aee621898a89c1d78c0d78e77b53724eaa/_data",
        "Destination": "/datavolume01",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    },
    {
        "Type": "volume",
        "Name": "d8383a8dc4b2016c0df7a29fe05f6b3dabd57565d63624e83a6ca08719ccbfb0",
        "Source": "/var/lib/docker/volumes/d8383a8dc4b2016c0df7a29fe05f6b3dabd57565d63624e83a6ca08719ccbfb0/_data",
        "Destination": "/datavolume02",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
]
```
对应的容器就是了；我们用inspect命令看下容器的详情，我么看下它下面的挂载详情，可以看到我们刚才设置的两个挂载目录以及挂载上去了，并且不出意外这个source就是docker容器和我们本机目录默认的挂载地址；

[![](https://z3.ax1x.com/2021/05/10/gNXWVg.png)](https://imgtu.com/i/gNXWVg)

果然，就是这个目录下，我们刚新增的目录被挂载到这个目录下了，且新增的文件已经同步过去了

### 匿名挂载&具名挂载
上面我们看到，我们用dockerFile脚本指定了两个挂载卷，docker默认把这两个卷挂载到docker目录下，且随机生成了一个id,辨识度不高，难以维护；这种docker自动挂载的我们没有指定挂载目录的就是匿名挂载，那什么样的才是具名挂载呢？
```shell
docker volume help #查看卷相关命令
docker volume ls #查看所有的挂载卷
# 匿名挂载
docker run -d -P --name tomcat01 -v /etc/tomcat tomcat:9.0
# 具名挂载
docker run -d -P --name tomcat02 -v tomcatconfig:/etc/tomcat tomcat:9.0
# 指定目录挂载
docker run -d -P --name tomcat03 -v /home/data/tomcatconfig:/etc/tomcat tomcat:9.0
# -v命令后路径如果是/开头说明就是一个指定目录挂载，如果不是/开头就是指定名称的具名挂载
```

> 小结：本篇博客我们自己写了一个dockerFile文件，看到了镜像的加载过程，对与镜像的分层概念有了更深层次的理解；也通过dokcerFile的VOLUME 命令了解了dockerFile挂载卷的方法，以及了解了具名挂载和匿名挂载的区别；
